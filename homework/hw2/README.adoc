= Домашно 2: Свързани списъци
:toc: left
:toc-title: Съдържание
:source-highlighter: highlightjs

== Задание

Целта на това домашно е да се упражнят операциите със https://en.wikipedia.org/wiki/Linked_list[свързан списък] (linked list).

https://en.wikipedia.org/wiki/Run-length_encoding[Run-length encoding (RLE)] е проста схема на кодиране, която може да се приложи върху редица от елементи, за да се компресира нейното съдържание. При нея всяка поредица от _N > 0_ повторения на елемента _X_ се представя като наредена двойка _(N, X)_. Например редицата

    A, A, A, A, A, A, A, B, A, B, B, B, B, B, B, C, B

може да се представи чрез RLE като редицата

    (7,A), (1,B), (1,A), (6,B), (1,C), (1,B)

За целите на задачата приемаме, че в RLE представянето не може да има две последователни двойки с еднакъв елемент _X_.
Например следната редица НЕ Е валидно представяне на по-горния пример:

    (3,A), (4,A), (1,B), (1,A), (6,B), (1,C), (1,B)

Както може да се види, колкото повече повторения има в редицата, толкова по-добро ниво на компресия ще се получи. Респективно, ако повторенията са малко или няма такива, RLE представянето ще заема повече място от оригинала.

Довършете реализацията на класа `RleString`, който представя символен низ от символи от тип `char`, кодиран чрез RLE. 

Вътрешно класът трябва да запазва информацията в свързан списък. Всеки възел в него отговаря на една двойка от RLE редицата:

[source, cpp]
----
class Node {
public:
    char symbol;  /// Symbol that is repeated one or more times
    size_t count; /// Number of repetitions of the symbol
    Node* next;   /// Next node in the linked list
};
----

Описанието на интерфейса на класа `RleString` (вкл. какво трябва да правят и как да се държат неговите функции) можете да намерите във файла link:template/src/RleString.h[`RleString.h`].

== Бележки

* С изключение на `toString`, останалите функции трябва да работят директно със свързания списък. Например, решение за `insertAt`, което първо преобразува обекта до `std::string`, добавя в него символа и след това преобразува резултата до `RleString` НЕ Е валидно.
* В задачата трябва сами да реализирате операциите със свързан списък. В решението НЕ МОЖЕ да се използват контейнерите от STL (в това число `std::list`, `std::vector` и т.н.) или друга библиотека.


## Шаблон

Както и за предишното домашно, за това също е предоставен шаблон, в който да работите. Той съдържа CMake проект, в който предварително е създадена структурата на решението, а също и unit test-ове, които покриват интерфейса на класа `RleStrings`. Можете да намерите шаблона в директорията link:template/[`template/`]

Разположете имплементацията на `RleString` във файла link:template/src/RleString.cpp[`RleString.cpp`]. В шаблона той е оставен почти празен, затова проектът не може да се компилира веднага след свалянето му.

Започнете като добавите празни дефиниции за всички функции от класа `RleString` в `.cpp` файла. За функциите, които трябва да връщат стойност може да връщате фиктивни такива. Например, `size()` може да връща `0`, `toString` може да връща празен `std::string` обект, предикатите могат да връщат `false` и т.н. Целта ви е да достигнете състояние, в което можете да компилирате проекта. След като го направите, започнете да имплементирате решението.

**Важно:** В решението си НЕ може да променяте интерфейса, който е описан в задачата, нито предоставените тестове. Например НЕ може да променяте броя на параметрите на дадена функция, да променяте името ѝ, да премахвате или променяте тестове и т.н. Възможно е обаче да добавите нови членове на класа.

Например, едно нещо, което трябва да добавите са член-променлви. Добавете ги на мястото на съответния коментар в кода. Също, ако имате нужда от допълнителни функции (било то `public` или `private`), можете да го направите. Можете да добавяте и нови класове и т.н.

Препоръчваме ви да покривате с подходящи Unit Test-ве единиците, които добавяте. За по-подредено, не добавяйте вашите тестове в предоставения в шаблона файл с тестове, а създайте отделен файл (или файлове), в който да ги разпишете.
