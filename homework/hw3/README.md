# Домашно 3: Двоично дърво

## Задание

Целта на това домашно е да се упражнят операциите с [двоично дърво (binary tree)](https://en.wikipedia.org/wiki/Binary_tree).

Възел в двоично дърво ще представяме чрез обекти от следния тип:

```cpp
template <typename T>
class Node {
public:
    T data = T();          // Данни съхранени във възела
    Node* left = nullptr;  // Указател към ляв наследник или nullptr ако няма такъв
    Node* right = nullptr; // Указател към десен наследник или nullptr ако няма такъв
};
```

Двоично дърво ще представяме чрез указател към неговия корен. Празното дърво ще представяме чрез указател със стойност `nullptr`. За определеност считаме, че в дървото може да има повторение на елементи. Вляво от всеки възел има само елементи по-малки от него, а вдясно – по-големи или равни.



Реализирайте описаните по-долу шаблони на функции.

### Проверка за балансираност

```cpp
template<typename T>
bool isBalanced(const Node<T>* rootptr)
```

Проверява дали дървото с корен `rootptr` е [балансирано по тегло (weight-balanced)](https://en.wikipedia.org/wiki/Binary_search_tree#Weight-balanced_trees). Напомняме, че това значи, че за всеки възел в дървото е вярно, че разликата между теглата на левия и десния му наследник, взета по модул, е не повече от 1. За определеност приемаме, че празното дърво е такова.

### Проверка за нареденост

```cpp
template<typename T>
bool isBst(const Node<T>* rootptr)
```

Проверява дали дървото с корен `rootptr` е [двоично наредено дърво (binary search tree)](https://en.wikipedia.org/wiki/Binary_search_tree). За определеност приемаме, че празното дърво е такова.

### Освобождаване на паметта заделена за двоично дърво

```cpp
template<typename T>
void release(const Node<T>* rootptr)
```

Освобождава паметта заета от дървото с корен `rootptr`.
Ако дървото е празно (`nullptr`), функцията да не прави нищо.
Паметта за кутиите да се освобождава чрез `delete`.

**Забележка:** за тази функция не са предоставени тестове.

### Построяване на балансирано по тегло двоично наредено дърво

```cpp
template<typename T>
Node<T>* toBalanced(std::vector<T> data)
```

Получава масив `data` от данни от тип `T`. Построява по него балансирано по тегло двоично дърво и връща указател към корена му. Ако масивът е празен, да се връща `nullptr` (празното дърво).

Функцията трябва да работи така, че ако масивът е сортиран в нарастващ ред и в него няма повторения на елементи, да се получава балансирано двоично наредено дърво.

Построяването да има времева сложност не по-голяма от _O(n)_. [Външната сложност (auxilary complexity)](https://cs.stackexchange.com/questions/108505/difference-between-auxiliary-space-v-s-space-complexity) да бъде _O(1)_. Забележете, че вариант с n-кратно прилагане на "наивно вмъкване" в дърво не върши работа, защото би бил с времева сложност _O(n log(n))_.

Паметта за кутиите на дървото да се заделя с `new`. Ако по време на изграждането на дървото възникне грешка (например няма достатъчно памет за заделяне на нова кутия), функцията трябва да се погрижи да почисти вече заделената от нея памет. Не бива да се допуска изтичане на памет.

Ако построяването на дървото не може да приключи успешно поради недостиг на памет да се хвърля изключение от тип `std::bad_alloc`.

_Упътване: Вземете средния елемент на масива. Той ще послужи за корен на дървото. След това постройте лявото и дясното му поддърво от така получените две части на масива (вляво и вдясно на средния елемент). Ако в даден момент не можете да продължите операцията, използвайте вече написаната `release` за освобождаване на вече заделената памет. По-долу е даден пример за сортиран масив и възможен вариант на дърво, което би се получило за него._

```text
{ -1, 0, 1, 3, 5, 7, 10, 100 }

        5
      /   \
     /     \
    1      10
   / \    /  \
  0   3  7   100
 /
-1
```

### Преобразуване на дърво до динамичен масив

```cpp
template<typename T>
std::vector<T> toVector(const Node<T>* rootptr)
```

Получава указател `rootptr` към корена на двоично наредено дърво. Построява и връща динамичен масив от елементите на дървото, в ред получен чрез обхождане [ляво-корен-дясно (inorder)](https://en.wikipedia.org/wiki/Tree_traversal#In-order,_LNR).

### Събиране на всички елементи от дадено ниво

```cpp
template<typename T>
std::vector<T> level(const Node<T>* rootptr, int level)
```

Намира всички елементи на дървото с корен `rootptr`, които се намират на ниво `level` и ги връща като динамичен масив. Елементите да бъдат наредени в масива точно в реда, в който се срещат в дървото от ляво на дясно. Ако дъвото е празно или в него няма ниво `level`, функцията да връща празен масив.

По-долу е дадено примерно дърво и какво трябва да се върне за неговите нива.

```text
       50
      /  \
    30    60
   /     /  \
  10    40  70
 /
-5

Ниво 0: {50}
Ниво 1: {30, 60}
Ниво 2: {10, 40, 70}
Ниво 3: {-5}
Ниво 4: {}
Ниво 5: {}
и т.н.
```

## Организация на решението

Както и за предишните домашни и за това е предоставен шаблон, в който да работите. Той съдържа CMake проект, в който предварително е създадена структурата на решението, а също и unit test-ове, които покриват функциите от заданието. Можете да намерите шаблона в директорията [`template/`](template/).

В шаблона ще намерите файл [`Node.h`](template/src/Node.h), който съдържа дефиницията на класа `Node`. В него има помощни член-функции, които можете да използвате наготово. Разгледайте ги преди да преминете към решаване на задачата. Те могат да са ви полезни и да опростят решението ви. Този клас е покрит с unit test-ове във файла [`NodeTest.cpp`](template/test/TestNode.cpp).

Решението си трябва да разположите във файла [`Solution.h`](template/src/Solution.h).

Unit test-овете, които покриват функциите от заданието са във файла [`TestSolution.cpp`](template/test/TestSolution.cpp). В решението си НЕ може да променяте този файл. Ако искате да дефинирате собствени тестове, разпишете ги във файла [`TestAdditional.cpp`](template/test/TestSolution.cpp).

Възможно е предоставените тестове да не покриват всички възможни случаи. Ако смятате, че има още нещо, което да се провери, добавете свои тестове в `TestAdditional.cpp`.

## Уточнения

* Тестовете в решението не проверяват за изтичане на памет или за поведението на програмата в случай на недостатъчна памет.
* Подзадачите може да се решат както итеративно, така и рекурсивно. Сами преценете как да подходите за всяка от тях.
* В задачата се очаква да работите директно с възлите от тип `Node`. Няма нужда да разписвате нови класове.
* В решението си НЕ може да променяте интерфейса, който е описан в задачата, нито предоставените тестове. Например, НЕ може да променяте броя на параметрите на дадена функция, да променяте името ѝ, да премахвате или променяте тестове и т.н.
* НЕ може да променяте представянето на дървото (класа `Node`). Например, НЕ може да добавяте указател към родител във възлите и т.н. Възможно е да добавите нови помощни член-функции, ако имате нужда.
* В решението може да използвате наготово `std::stack` и `std::queue` от STL.
* Ако имате нужда от помощни функции, можете да ги добавите в `Solution.h`.
* Когато предавате решението си запазете структурата на шаблона. Трябва да го предадете като един `.zip` архив съдържащ директориите `src/` и `test/`, а също и файла `CMakeLists.txt`. НЕ включвайте в архива директориите, които се създават от IDE-то ви (например `.vscode/`, `out/`, `build/` и т.н.).
